var blockStore = [];
blockStore["brick_inner"] = new Sprite("images/bricks.bmp", 16, 16, 0, 0, 0, 0);
blockStore["brick_single"] = new Sprite("images/bricks.bmp", 16, 16, 16, 0, 0, 0);
blockStore["brick_top"] = new Sprite("images/bricks.bmp", 16, 16, 32, 0, 0, 0);
blockStore["brick_top_left"] = new Sprite("images/bricks.bmp", 16, 16, 48, 0, 0, 0);
blockStore["brick_top_right"] = new Sprite("images/bricks.bmp", 16, 16, 64, 0, 0, 0);
blockStore["brick_left_right"] = new Sprite("images/bricks.bmp", 16, 16, 80, 0, 0, 0);
blockStore["brick_left"] = new Sprite("images/bricks.bmp", 16, 16, 96, 0, 0, 0);
blockStore["brick_right"] = new Sprite("images/bricks.bmp", 16, 16, 112, 0, 0, 0);
blockStore["brick_back"] = new Sprite("images/bricks.bmp", 16, 16, 128, 0, 0, 0);


blockStore["soil_inner"] = new Sprite("images/soil.bmp", 16, 16, 0, 0, 0, 0);
blockStore["soil_single"] = new Sprite("images/soil.bmp", 16, 16, 64, 0, 0, 0);
blockStore["soil_top"] = new Sprite("images/soil.bmp", 16, 16, 16, 0, 0, 0);
blockStore["soil_top_left"] = new Sprite("images/soil.bmp", 16, 16, 32, 0, 0, 0);
blockStore["soil_top_right"] = new Sprite("images/soil.bmp", 16, 16, 48, 0, 0, 0);
blockStore["soil_left_right"] = new Sprite("images/soil.bmp", 16, 16, 112, 0, 0, 0);
blockStore["soil_left"] = new Sprite("images/soil.bmp", 16, 16, 80, 0, 0, 0);
blockStore["soil_right"] = new Sprite("images/soil.bmp", 16, 16, 96, 0, 0, 0);
blockStore["soil_back"] = new Sprite("images/soil.bmp", 16, 16, 128, 0, 0, 0);

blockStore["dirt_inner"] = new Sprite("images/soil.bmp", 16, 16, 0, 0, 0, 0);
blockStore["dirt_single"] = new Sprite("images/soil.bmp", 16, 16, 192, 0, 0, 0);
blockStore["dirt_top"] = new Sprite("images/soil.bmp", 16, 16, 144, 0, 0, 0);
blockStore["dirt_top_left"] = new Sprite("images/soil.bmp", 16, 16, 160, 0, 0, 0);
blockStore["dirt_top_right"] = new Sprite("images/soil.bmp", 16, 16, 176, 0, 0, 0);
blockStore["dirt_left_right"] = new Sprite("images/soil.bmp", 16, 16, 112, 0, 0, 0);
blockStore["dirt_left"] = new Sprite("images/soil.bmp", 16, 16, 80, 0, 0, 0);
blockStore["dirt_right"] = new Sprite("images/soil.bmp", 16, 16, 96, 0, 0, 0);
blockStore["dirt_back"] = new Sprite("images/soil.bmp", 16, 16, 128, 0, 0, 0);


blockStore["sand_inner"] = new Sprite("images/sand.bmp", 16, 16, 0, 0, 0, 0);
blockStore["sand_single"] = new Sprite("images/sand.bmp", 16, 16, 64, 0, 0, 0);
blockStore["sand_top"] = new Sprite("images/sand.bmp", 16, 16, 16, 0, 0, 0);
blockStore["sand_top_left"] = new Sprite("images/sand.bmp", 16, 16, 32, 0, 0, 0);
blockStore["sand_top_right"] = new Sprite("images/sand.bmp", 16, 16, 48, 0, 0, 0);
blockStore["sand_left_right"] = new Sprite("images/sand.bmp", 16, 16, 112, 0, 0, 0);
blockStore["sand_left"] = new Sprite("images/sand.bmp", 16, 16, 80, 0, 0, 0);
blockStore["sand_right"] = new Sprite("images/sand.bmp", 16, 16, 96, 0, 0, 0);
blockStore["sand_back"] = new Sprite("images/sand.bmp", 16, 16, 128, 0, 0, 0);

blockStore["rock_inner"] = new Sprite("images/rock.bmp", 16, 16, 0, 0, 0, 0);
blockStore["rock_single"] = new Sprite("images/rock.bmp", 16, 16, 64, 0, 0, 0);
blockStore["rock_top"] = new Sprite("images/rock.bmp", 16, 16, 16, 0, 0, 0);
blockStore["rock_top_left"] = new Sprite("images/rock.bmp", 16, 16, 32, 0, 0, 0);
blockStore["rock_top_right"] = new Sprite("images/rock.bmp", 16, 16, 48, 0, 0, 0);
blockStore["rock_left_right"] = new Sprite("images/rock.bmp", 16, 16, 112, 0, 0, 0);
blockStore["rock_left"] = new Sprite("images/rock.bmp", 16, 16, 80, 0, 0, 0);
blockStore["rock_right"] = new Sprite("images/rock.bmp", 16, 16, 96, 0, 0, 0);
blockStore["rock_back"] = new Sprite("images/rock.bmp", 16, 16, 128, 0, 0, 0);

blockStore["leaf_inner"] = new Sprite("images/tree.bmp", 16, 16, 0, 0, 0, 0);
blockStore["leaf_single"] = new Sprite("images/tree.bmp", 16, 16, 64, 0, 0, 0);
blockStore["leaf_top"] = new Sprite("images/tree.bmp", 16, 16, 16, 0, 0, 0);
blockStore["leaf_top_left"] = new Sprite("images/tree.bmp", 16, 16, 32, 0, 0, 0);
blockStore["leaf_top_right"] = new Sprite("images/tree.bmp", 16, 16, 48, 0, 0, 0);
blockStore["leaf_left_right"] = new Sprite("images/tree.bmp", 16, 16, 112, 0, 0, 0);
blockStore["leaf_left"] = new Sprite("images/tree.bmp", 16, 16, 80, 0, 0, 0);
blockStore["leaf_right"] = new Sprite("images/tree.bmp", 16, 16, 96, 0, 0, 0);

blockStore["wood_inner"] = new Sprite("images/wood.bmp", 16, 16, 0, 0, 0, 0);
blockStore["wood_single"] = new Sprite("images/wood.bmp", 16, 16, 64, 0, 0, 0);
blockStore["wood_top"] = new Sprite("images/wood.bmp", 16, 16, 16, 0, 0, 0);
blockStore["wood_top_left"] = new Sprite("images/wood.bmp", 16, 16, 32, 0, 0, 0);
blockStore["wood_top_right"] = new Sprite("images/wood.bmp", 16, 16, 48, 0, 0, 0);
blockStore["wood_left_right"] = new Sprite("images/wood.bmp", 16, 16, 112, 0, 0, 0);
blockStore["wood_left"] = new Sprite("images/wood.bmp", 16, 16, 80, 0, 0, 0);
blockStore["wood_right"] = new Sprite("images/wood.bmp", 16, 16, 96, 0, 0, 0);
blockStore["wood_back"] = new Sprite("images/wood.bmp", 16, 16, 128, 0, 0, 0);



var pump = new Sprite("images/pump.bmp", 16, 16, 0, 0, 0, 0);
var watercap = new Sprite("images/watercap.bmp", 16, 2, 0, 0, 0, 0);
var player = new Sprite("images/player.png", 32, 32, 32, 0, 0, 0);
var playerWalking = new Sprite("images/player.png", 32, 32, 0, 64, 3, 400);
var banditRight = new Sprite("images/bandit.png", 32, 32, 0, 64, 3, 400);
var banditLeft = new Sprite("images/bandit.png", 32, 32, 0, 32, 3, 400);

var banditArray = [[512,64,0]];

var left = false;
var right = false;
var jump = false;
var offSetX = -748;
var offSetY = 32;
//var mass = [];
//var backArray = [];
var timer = new Timer();
//var blocks = [];
var playerX = 1232;
var playerY = 272;
var ctx;
var ctxBack
var mouseX
var mouseY
var clicked = false;
var modBack = false;

function saveGame() {

    localStorage.playerX = playerX;
    localStorage.playerY = playerY;
    localStorage.offSetX = offSetX;
    localStorage.offSetY = offSetY;

    localStorage.backArray = JSON.stringify(backArray);
    localStorage.mass = JSON.stringify(mass);
    localStorage.blocks = JSON.stringify(blocks);

}

function loadGame() {

    playerX = parseInt(localStorage.playerX);
    playerY = parseInt(localStorage.playerY);
    offSetX = parseInt(localStorage.offSetX);
    offSetY = parseInt(localStorage.offSetY);

    backArray = JSON.parse(localStorage.backArray);
    mass = JSON.parse(localStorage.mass);
    blocks = JSON.parse(localStorage.blocks);
}

function findPos(obj) {
    var curleft = 0, curtop = 0;
    if (obj.offsetParent) {
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        } while (obj = obj.offsetParent);
        return { x: curleft, y: curtop };
    }
    return undefined;
}

function toggleMenu(){

    var menu = document.getElementById("menu");

    if (menu.style.right == "-200px") {

        menu.style.right = "0px";
    }
    else{
        menu.style.right = "-200px";
    }
}

function buildMenu() {

    var menuArea = document.getElementById("menuArea");   

    var string = "<div class='block' onclick='_selectedItem = 6;'><img src='images/bricks.bmp' alt='brick' title='Brick'></div>";
    string += "<div class='block' onclick='_selectedItem = 1;'><img src='images/soil.bmp' alt='soil' title='Soil'></div>";
    string += "<div class='block' onclick='_selectedItem = 2;'><img src='images/sand.bmp' alt='sand' title='Sand'></div>";
    string += "<div class='block' onclick='_selectedItem = 3;'><img src='images/rock.bmp' alt='rock' title='Rock'></div>";
    string += "<div class='block' onclick='_selectedItem = 5;'><img src='images/wood.bmp' alt='wood' title='Wood'></div>";
    string += "<div class='block' onclick='_selectedItem = 99;'><img src='images/pump.bmp' alt='pump' title='Pump'></div>";
    string += "<div class='block' onclick='_selectedItem = -1;'><img src='images/water.bmp' alt='water' title='Water'></div>";
    string += "<div class='largeBlock' onclick='saveGame();'><p>Save</p></div>";
    string += "<div class='largeBlock' onclick='loadGame();'><p>Load</p></div>";
    string += "<div class='largeBlock' onclick='modBack = true;'><p>Background</p></div>";
    string += "<div class='largeBlock' onclick='modBack = false;'><p>Foreground</p></div>";



    menuArea.innerHTML = string;

    var menu = document.getElementById("menu");
    menu.style.right = "-200px";
}

var _selectedItem = 0;

function showCoordinates(evt, canvas) {
    //mouseX = evt.clientX - canvas.offsetLeft;
    //mouseY = evt.clientY - canvas.offsetTop;

    var pos = findPos(canvas);
    mouseX = evt.clientX - pos.x;
    mouseY = evt.clientY - pos.y;


    //mouseX = evt.clientX - canvas.offsetLeft + document.body.scrollLeft + document.documentElement.scrollLeft; 
    //mouseY = evt.clientY  - canvas.offsetTop + document.body.scrollTop + document.documentElement.scrollTop; 

    mouseX = parseInt((mouseX - offSetX) / 16);
    mouseY = parseInt((mouseY - offSetY) / 16);

    var coordinateDisplay = "x=" + mouseX + ", y=" + mouseY;

    if(modBack){
        
        if (backArray[mouseY][mouseX] != null) {

            backArray[mouseY][mouseX] = null;
        }
        else {

            if (_selectedItem == -1) {

                //mass[mouseY][mouseX] = 1;
            }
            else {

                backArray[mouseY][mouseX] = _selectedItem;
            }
            
        }
    }
    else{

        if (blocks[mouseY][mouseX] != null) {

            blocks[mouseY][mouseX] = null;
        }
        else {

            if (_selectedItem == -1) {

                mass[mouseY][mouseX] = 1;
            }
            else {

                blocks[mouseY][mouseX] = _selectedItem;
            }
            
        }
    }

    clicked = true;

}

function Terrain() {

    this.sprite;
    this.name;
    this.solid
}

function init() {

    var c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");

    c = document.getElementById("myCanvasback");
    ctxBack = c.getContext("2d");

    buildMenu();

    setInterval("loopGame()", 10);
    setInterval("water()", 30);
    setInterval("movement()", 100);
}


//Block types
var AIR = 0;
var GROUND = 1;
var WATER = 2;

function Timer() {

    this.date = new Date();

    this.update = function () {

        var d = new Date();
        this.date = d;
    }

    this.getMilliseconds = function () {

        return this.date.getTime();
    }

    this.getSeconds = function () {

        return Math.round(this.date.getTime() / 1000);
    }
}

function onKeyDown(evt) {


    if (evt.keyCode == 65) {

        left = true;

    }
    else if (evt.keyCode == 68) {

        right = true;

    }
    else if (evt.keyCode == 87) {

        jump = true;

    }

}

this.addEventListener("keydown", onKeyDown, false);
this.addEventListener("keyup", onKeyUp, false);

function intersectRect(pX, pY, x, y) {
    return !(pX > (x * 16) + 32 ||
             pX + 32 < (x * 16) ||
             pY > (y * 16) + 32 ||
             pY + 32 < (y * 16));
}

function onKeyUp(evt) {

    if (evt.keyCode == 65) {

        left = false;
    }
    else if (evt.keyCode == 68) {

        right = false;
    }
    else if (evt.keyCode == 87) {

        jump = false;
    }
}

function movement() {

    // Player movement processed.
    var collX = parseInt((playerX - 1) / 16);
    var collX1 = parseInt((playerX + 33) / 16);
    var collX2 = parseInt((playerX + 16) / 16);
    var collY = parseInt(((playerY) / 16));
    var collY1 = parseInt(((playerY + 31) / 16));
    var collY2 = parseInt(((playerY + 16) / 16));

    if (right == true) {

        playerX += 8;
        offSetX -= 8;

        if (blocks[collY][collX1] != null || blocks[collY1][collX1] != null || blocks[collY2][collX1] != null) {

            playerX -= 8;
            offSetX += 8;
        }        

    }
    else if (left == true) {

        playerX -= 8;
        offSetX += 8;

        if (blocks[collY][collX] != null || blocks[collY1][collX] != null || blocks[collY2][collX] != null) {

            playerX += 8;
            offSetX -= 8;
        }       

    }    

    if (jump == true) {

        playerY -= 16;
        offSetY += 16;
    }
    else {

        playerY += 16;
        offSetY -= 16;
    }

    collY = parseInt(((playerY) / 16));
    collY1 = parseInt(((playerY + 31) / 16));
    collY2 = parseInt(((playerY + 16) / 16));
    collX = parseInt(playerX / 16);
    collX1 = parseInt((playerX + 31) / 16);
    collX2 = parseInt((playerX + 16) / 16);

    if (blocks[collY1][collX] != null || blocks[collY1][collX1] != null || blocks[collY1][collX2] != null) {

        playerY -= 16;
        offSetY += 16;

        collY = parseInt(((playerY) / 16));
        collY1 = parseInt(((playerY + 31) / 16));
        collY2 = parseInt(((playerY + 16) / 16));
    }

    if (blocks[collY][collX] != null || blocks[collY][collX1] != null || blocks[collY][collX2] != null) {

        playerY += 16;
        offSetY -= 16;
    }

    var noBandits = banditArray.length;

    for (i = 0; i < noBandits; i++) {

        if (banditArray[i][2] == 0) {
            
            var banditNextX = parseInt((banditArray[i][1] - 8) / 16);
            var banditNextY = parseInt((banditArray[i][0] + 40) / 16);
            var banditCurrentY = parseInt((banditArray[i][0] + 31) / 16);
            var banditCurrentYTop = parseInt((banditArray[i][0]) / 16);

            if (blocks[banditCurrentY][banditNextX] == null && blocks[banditCurrentYTop][banditNextX] == null && blocks[banditNextY][banditNextX] != null) {

                banditArray[i][1] -= 8;
            }
            else {
                banditArray[i][2] = 1;
            }
        }
        else {
            
            var banditNextX = parseInt((banditArray[i][1] + 24) / 16);
            var banditNextY = parseInt((banditArray[i][0] + 40) / 16);
            var banditCurrentY = parseInt((banditArray[i][0] + 31) / 16);
            var banditCurrentYTop = parseInt((banditArray[i][0]) / 16);

            if (blocks[banditCurrentY][banditNextX] == null && blocks[banditCurrentYTop][banditNextX] == null && blocks[banditNextY][banditNextX] != null) {

                banditArray[i][1] += 8;
            }
            else {
                banditArray[i][2] = 0;
            }
        }
    }
}

function loopGame() {

    ctx.clearRect(0, 0, 1000, 640);
    ctxBack.clearRect(0, 0, 1000, 640);
    timer.update();    

    if (right == true) {        

        playerWalking.setPosition(playerX + offSetX, playerY + offSetY);
        playerWalking.animate(ctx, timer);
        playerWalking.draw(ctx);

    }
    else if (left == true) {        

        ctx.save();
        ctx.translate(30 * 0.5, +30 * 0.5);
        ctx.scale(-1, 1);
        ctx.translate(-30 * 0.5, -30 * 0.5);

        playerWalking.setPosition(-playerX + -offSetX, playerY + offSetY);
        playerWalking.animate(ctx, timer);
        playerWalking.draw(ctx);

        ctx.restore();

    }
    else {

        player.setPosition(playerX + offSetX, playerY + offSetY);
        player.animate(ctx, timer);
        player.draw(ctx);
    }       
          
    var noBandits = banditArray.length;

    for (i = 0; i < noBandits; i++) {

        if (banditArray[i][2] == 0) {

            banditLeft.setPosition(banditArray[i][1] + offSetX, banditArray[i][0] + offSetY);
            banditLeft.animate(ctx, timer);
            banditLeft.draw(ctx);
            
        }
        else {

            banditRight.setPosition(banditArray[i][1] + offSetX, banditArray[i][0] + offSetY);
            banditRight.animate(ctx, timer);
            banditRight.draw(ctx);            
        }
    }


    var MAX_Y = 100;
    var MAX_X = 200;
    var startY = parseInt((playerY / 16)) - 21;
    var endY = parseInt((playerY / 16)) + 21;
    var startX = parseInt((playerX / 16)) - 40;
    var endX = parseInt((playerX / 16)) + 40;
    var localBlockstore = blockStore;
    var localBlocks = blocks;

    if (startY < 0) { startY = 0; }
    if (endY > MAX_Y) { endY = MAX_Y; }
    if (startX < 0) { startX = 0; }
    if (endX > MAX_X) { endX = MAX_X; }
    
    for (y = startY; y <= endY; y++) {
        
        for (x = startX; x <= endX; x++) {

            if ((backArray[y][x] != null) && backArray[y][x] != "") {

                switch (backArray[y][x]) {

                    case 6:
                    case 0:
                        var blockType = "brick";
                        break;

                    case 1:
                        var blockType = "soil";
                        break;

                    case 2:
                        var blockType = "sand";
                        break;

                    case 3:
                        var blockType = "rock";
                        break;

                    case 5:

                        var blockType = "wood";
                        break;
                }

                localBlockstore[blockType + "_back"].setPosition(x * 16 + offSetX, y * 16 + offSetY);
                localBlockstore[blockType + "_back"].draw(ctxBack);
            }
            ctx.fillStyle = "rgba(0,60,200,0.5)";
           if (mass[y][x] > 0.05 && mass[y - 1][x] >= 0.05) {
                
                //ctx.fillStyle = "rgba(200,60,0,1)";
                ctx.fillRect(x * 16 + offSetX, (y * 16 + offSetY), 16, 16);
            }
            else if (mass[y][x] > 0.9) {
                
                ctx.fillRect(x * 16 + offSetX, (y * 16 + offSetY), 16, 16);
                watercap.setPosition(x * 16 + offSetX, y * 16 + offSetY);
                watercap.draw(ctx);                	
            }
            else if (mass[y][x] > 0.8) {
                
                ctx.fillRect(x * 16 + offSetX, (y * 16 + offSetY) + 3.2, 16, 12.8);
                watercap.setPosition(x * 16 + offSetX, (y * 16 + offSetY) + 3.2);
                watercap.draw(ctx);
            }
            else if (mass[y][x] > 0.6) {
                
                ctx.fillRect(x * 16 + offSetX, (y * 16 + offSetY) + 6.4, 16, 9.6);
                watercap.setPosition(x * 16 + offSetX, (y * 16 + offSetY) + 6.4);
                watercap.draw(ctx);
            }
            else if (mass[y][x] > 0.4) {
                
                ctx.fillRect(x * 16 + offSetX, (y * 16 + offSetY) + 9.6, 16, 6.4);
                watercap.setPosition(x * 16 + offSetX, (y * 16 + offSetY) + 9.6);
                watercap.draw(ctx);
            }
            else if (mass[y][x] > 0.2) {
                
                ctx.fillRect(x * 16 + offSetX, (y * 16 + offSetY) + 12.8, 16, 3.2);
                watercap.setPosition(x * 16 + offSetX, (y * 16 + offSetY) + 12.8);
                watercap.draw(ctx);
            }
            else if (mass[y][x] > 0.05) {
                
                ctx.fillRect(x * 16 + offSetX, (y * 16 + offSetY) + 15, 16, 1);
                watercap.setPosition(x * 16 + offSetX, (y * 16 + offSetY) + 15);
                watercap.draw(ctx);
            }
            
           if (localBlocks[y][x] == null) { continue; }

            switch (localBlocks[y][x]) {

                case 0:
                case 6:
                    var blockType = "brick";
                    break;
                    
                case 1:
                    var blockType = "soil";

                    if (blockType == "soil" && (localBlocks[y - 1][x] != null || mass[y - 1][x] != 0)) {

                        blockType = "dirt";
                    }
                    break;

                case 2:
                    var blockType = "sand";
                    break;

                case 3:
                    var blockType = "rock";
                    break;

                case 4:
                    var blockType = "leaf";
                    break;

                case 5:

                    var blockType = "wood";
                    break;

                case 99:                    

                    pump.setPosition(x * 16 + offSetX, y * 16 + offSetY);
                    pump.draw(ctx);
                    
                    continue;
                    break;
            } 

            if ((localBlocks[y][x - 1] != localBlocks[y][x]) && (localBlocks[y][x + 1] != localBlocks[y][x]) && (y - 1 >= startY && localBlocks[y - 1][x] != localBlocks[y][x])) {
                
                // if (blockType == "soil" && (blocks[y - 1][x] != null || mass[y - 1][x] != 0)) {

                //     blockType = "dirt";
                // }

                blockType += "_single";
            }
            else if ((localBlocks[y][x - 1] == localBlocks[y][x]) && (localBlocks[y][x + 1] == localBlocks[y][x]) && (y - 1 >= startY && localBlocks[y - 1][x] != localBlocks[y][x])) {
                
                // if (blockType == "soil" && (blocks[y - 1][x] != null || mass[y - 1][x] != 0)) {

                //     blockType = "dirt";
                // }

                blockType += "_top";
            }
            else if ((localBlocks[y][x - 1] != localBlocks[y][x]) && (localBlocks[y][x + 1] == localBlocks[y][x]) && (y - 1 >= startY && localBlocks[y - 1][x] != localBlocks[y][x])) {
                
                // if (blockType == "soil" && (blocks[y - 1][x] != null || mass[y - 1][x] != 0)) {

                //     blockType = "dirt";
                // }

                blockType += "_top_left";
            }
            else if ((localBlocks[y][x + 1] != localBlocks[y][x]) && (localBlocks[y][x - 1] == localBlocks[y][x]) && (y - 1 >= startY && localBlocks[y - 1][x] != localBlocks[y][x])) {
                
                // if (blockType == "soil" && (blocks[y - 1][x] != null || mass[y - 1][x] != 0)) {

                //     blockType = "dirt";
                // }

                blockType += "_top_right";
            }
            else if ((localBlocks[y][x + 1] != localBlocks[y][x]) && (localBlocks[y][x - 1] != localBlocks[y][x]) && (y - 1 >= startY && localBlocks[y - 1][x] == localBlocks[y][x])) {
                
                blockType += "_left_right";
            }
            else if ((localBlocks[y][x + 1] == localBlocks[y][x]) && (localBlocks[y][x - 1] != localBlocks[y][x]) && (y - 1 >= startY && localBlocks[y - 1][x] == localBlocks[y][x])) {
                
                blockType += "_left";
            }
            else if ((localBlocks[y][x - 1] == localBlocks[y][x]) && (localBlocks[y][x + 1] != localBlocks[y][x]) && (y - 1 >= startY && localBlocks[y - 1][x] == localBlocks[y][x])) {
                
                blockType += "_right";
            }
            else {
                
                blockType += "_inner";                
            }

            localBlockstore[blockType].setPosition(x * 16 + offSetX, y * 16 + offSetY);
            localBlockstore[blockType].draw(ctx); 
        }
    }
}




var MaxMass = 1.0; //The normal, un-pressurized mass of a full water cell
var MaxCompress = 0.2; //How much excess water a cell can store, compared to the cell above it
var MinMass = 0.0001;  //Ignore cells that are almost dry
var MinFlow = 0.00;
var map_width = 199;
var map_height = 99;
var MaxSpeed = 0.2;
var flow = 0;
var remaining_mass;

function pumping(x,y) {

    if (mass[y+1][x] >= 0.8 && mass[y - 1][x] <= 1.2 && (blocks[y - 1][x] == 99 || blocks[y - 1][x] == null)) {

        mass[y - 1][x] += mass[y + 1][x];
        mass[y + 1][x] = 0;
    }
}

function water() {

    var new_mass = mass;


    for (var y = map_height - 1; y >= 0; y--) {

        for (var x = 1; x < map_width; x++) {


            if (blocks[y][x] == 99) {
                pumping(x, y);
            }

            if (blocks[y][x] != null && blocks[y][x] != 20) { continue; }

            

            flow = 0;
            remaining_mass = mass[y][x];

            if ((blocks[y + 1][x] == 20 || blocks[y + 1][x] == null)) {

                flow = get_stable_state_b(remaining_mass + mass[y + 1][x]) - mass[y + 1][x];
                var waterFalling = false;
                if (flow > MinFlow) {
                    flow *= 0.5; //leads to smoother flow
                    waterFalling = true;
                }
                flow = fixer(flow, findMin(MaxSpeed, remaining_mass));
                

                new_mass[y][x] -= flow;

                if (new_mass[y][x] < 0 || isNaN(new_mass[y][x])) {
                    new_mass[y][x] = 0;
                }
                else if (new_mass[y][x] > 1) {
                    new_mass[y][x] = 1;
                }

                new_mass[y + 1][x] += flow;

                if (new_mass[y + 1][x] > 1 + MaxCompress) {
                    new_mass[y + 1][x] = 1 + MaxCompress;
                }

                
                remaining_mass -= flow;

                if (waterFalling && new_mass[y + 1][x] < 0.9) {
                    continue;
                }
                
            }

            if (remaining_mass <= 0) continue;

            if (blocks[y][x - 1] == null || blocks[y][x - 1] == 20) {
                //Equalize the amount of water in this block and it's neighbour
                flow = (mass[y][x] - mass[y][x - 1]) / 4;
                if (flow > MinFlow) { flow *= 0.5; }

                flow = fixer(flow, remaining_mass);

                new_mass[y][x] -= flow;

                if (new_mass[y][x] < 0 || isNaN(new_mass[y][x])) {
                    new_mass[y][x] = 0;
                }
                else if (new_mass[y][x] > 1) {
                    new_mass[y][x] = 1;
                }

                new_mass[y][x - 1] += flow;

                if (new_mass[y][x - 1] > 1 + MaxCompress) {
                    new_mass[y][x - 1] = 1 + MaxCompress;
                }

                remaining_mass -= flow;
            }

            if (remaining_mass <= 0) continue;

            if (blocks[y][x + 1] == null || blocks[y][x + 1] == 20) {
                //Equalize the amount of water in this block and it's neighbour
                flow = (mass[y][x] - mass[y][x + 1]) / 4;
                if (flow > MinFlow) { flow *= 0.5; }

                flow = fixer(flow, remaining_mass);

                new_mass[y][x] -= flow;

                if (new_mass[y][x] < 0 || isNaN(new_mass[y][x])) {
                    new_mass[y][x] = 0;
                }
                else if (new_mass[y][x] > 1) {
                    new_mass[y][x] = 1;
                }

                new_mass[y][x + 1] += flow;

                if (new_mass[y][x + 1] > 1 + MaxCompress) {
                    new_mass[y][x + 1] = 1 + MaxCompress;
                }

                remaining_mass -= flow;
            }

            if (remaining_mass <= 0) continue;

            //Up. Only compressed water flows upwards.
            if ((blocks[y - 1][x] == null || blocks[y - 1][x] == 20) && mass[y][x] > 1.0) {

                flow = get_stable_state_b(remaining_mass + mass[y - 1][x]);
                //flow = remaining_mass - get_stable_state_b( remaining_mass + mass[y-1][x] );
                if (flow > MinFlow) { flow *= 0.5; }
                flow = fixer(flow, findMin(MaxSpeed, remaining_mass));
                
                new_mass[y][x] -= flow;

                if (new_mass[y][x] < 0 || isNaN(new_mass[y][x])) {
                    new_mass[y][x] = 0;
                }
                else if (new_mass[y][x] > 1) {
                    //new_mass[y][x] = 1;
                }

                new_mass[y - 1][x] += flow;

                if (new_mass[y - 1][x] > 1) {
                    //new_mass[y-1][x] = 1;
                }

                remaining_mass -= flow;
            }

            if (remaining_mass <= MinMass) {
                new_mass[y][x] = 0;
            }

        }
    }

    for (var y = 1; y < map_height; y++) {
        for (var x = 1; x < map_width; x++) {
            mass[y][x] = new_mass[y][x];

        }
    }

    for (var y = 1; y < map_height; y++) {

        for (var x = 1; x < map_width; x++) {
            //Skip ground blocks
            if (blocks[y][x] != null && blocks[y][x] != 20) {

                continue;
            }
            //Flag/unflag water blocks
            if (mass[y][x] > MinMass) {
                //blocks[y][x] = 20;
            }
            else {
                //blocks[y][x] = null;
                //mass[y][x] = 0;
                //new_mass[y][x] = 0;
            }
        }
    }

    //Remove any water that has left the map
    for (var x = 0; x < map_width; x++) {
        mass[0][x] = 0;
        mass[map_height][x] = 0;
        new_mass[0][x] = 0;
        new_mass[map_height][x] = 0;
    }
    for (var y = 0; y < map_height; y++) {
        mass[y][0] = 0;
        mass[y][map_width] = 0;
        new_mass[y][0] = 0;
        new_mass[y][map_width] = 0;
    }

}

function findMin(one, two) {

    if (one > two) {
        return two;
    }
    else {
        return one;
    }
}

function fixer(_flow, _value) {

    if (_flow > _value) {

        _flow = _value;
    }


    return _flow;
}


function get_stable_state_b(total_mass) {
    if (total_mass >= 1) {
        return 1;
    } else if (total_mass < 2 * MaxMass + MaxCompress) {
        return (MaxMass * MaxMass + total_mass * MaxCompress) / (MaxMass + MaxCompress);
    } else {
        return (total_mass + MaxCompress) / 2;
    }
}
